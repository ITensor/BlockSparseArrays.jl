var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"EditURL = \"../../examples/README.jl\"","category":"page"},{"location":"#BlockSparseArrays.jl","page":"Home","title":"BlockSparseArrays.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A block sparse array type in Julia based on the BlockArrays.jl interface.","category":"page"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the package can be added as usual through the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"BlockSparseArrays\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using BlockArrays: BlockArrays, BlockedVector, Block, blockedrange\nusing BlockSparseArrays: BlockSparseArray, block_stored_length\nusing Test: @test, @test_broken\n\nfunction main()\n  # Block dimensions\n  i1 = [2, 3]\n  i2 = [2, 3]\n\n  i_axes = (blockedrange(i1), blockedrange(i2))\n\n  function block_size(axes, block)\n    return length.(getindex.(axes, Block.(block.n)))\n  end\n\n  # Data\n  nz_blocks = Block.([(1, 1), (2, 2)])\n  nz_block_sizes = [block_size(i_axes, nz_block) for nz_block in nz_blocks]\n  nz_block_lengths = prod.(nz_block_sizes)\n\n  # Blocks with contiguous underlying data\n  d_data = BlockedVector(randn(sum(nz_block_lengths)), nz_block_lengths)\n  d_blocks = [\n    reshape(@view(d_data[Block(i)]), block_size(i_axes, nz_blocks[i])) for\n    i in 1:length(nz_blocks)\n  ]\n  b = BlockSparseArray(nz_blocks, d_blocks, i_axes)\n\n  @test block_stored_length(b) == 2\n\n  # Blocks with discontiguous underlying data\n  d_blocks = randn.(nz_block_sizes)\n  b = BlockSparseArray(nz_blocks, d_blocks, i_axes)\n\n  @test block_stored_length(b) == 2\n\n  # Access a block\n  @test b[Block(1, 1)] == d_blocks[1]\n\n  # Access a zero block, returns a zero matrix\n  @test b[Block(1, 2)] == zeros(2, 3)\n\n  # Set a zero block\n  a₁₂ = randn(2, 3)\n  b[Block(1, 2)] = a₁₂\n  @test b[Block(1, 2)] == a₁₂\n\n  # Matrix multiplication\n  # TODO: Fix this, broken.\n  @test_broken b * b ≈ Array(b) * Array(b)\n\n  permuted_b = permutedims(b, (2, 1))\n  @test permuted_b isa BlockSparseArray\n  @test permuted_b == permutedims(Array(b), (2, 1))\n\n  @test b + b ≈ Array(b) + Array(b)\n  @test b + b isa BlockSparseArray\n  # TODO: Fix this, broken.\n  @test_broken block_stored_length(b + b) == 2\n\n  scaled_b = 2b\n  @test scaled_b ≈ 2Array(b)\n  @test scaled_b isa BlockSparseArray\n\n  # TODO: Fix this, broken.\n  @test_broken reshape(b, ([4, 6, 6, 9],)) isa BlockSparseArray{<:Any,1}\n\n  return nothing\nend\n\nmain()","category":"page"},{"location":"#BlockSparseArrays.jl-and-BlockArrays.jl-interface","page":"Home","title":"BlockSparseArrays.jl and BlockArrays.jl interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using BlockArrays: BlockArrays, Block\nusing BlockSparseArrays: BlockSparseArray\n\ni1 = [2, 3]\ni2 = [2, 3]\nB = BlockSparseArray{Float64}(i1, i2)\nB[Block(1, 1)] = randn(2, 2)\nB[Block(2, 2)] = randn(3, 3)\n\n# Minimal interface\n\n# Specifies the block structure\n@show collect.(BlockArrays.blockaxes(axes(B, 1)))\n\n# Index range of a block\n@show axes(B, 1)[Block(1)]\n\n# Last index of each block\n@show BlockArrays.blocklasts(axes(B, 1))\n\n# Find the block containing the index\n@show BlockArrays.findblock(axes(B, 1), 3)\n\n# Retrieve a block\n@show B[Block(1, 1)]\n@show BlockArrays.viewblock(B, Block(1, 1))\n\n# Check block bounds\n@show BlockArrays.blockcheckbounds(B, 2, 2)\n@show BlockArrays.blockcheckbounds(B, Block(2, 2))\n\n# Derived interface\n\n# Specifies the block structure\n@show collect(Iterators.product(BlockArrays.blockaxes(B)...))\n\n# Iterate over block views\n@show sum.(BlockArrays.eachblock(B))\n\n# Reshape into 1-d\n# TODO: Fix this, broken.\n# @show BlockArrays.blockvec(B)[Block(1)]\n\n# Array-of-array view\n@show BlockArrays.blocks(B)[1, 1] == B[Block(1, 1)]\n\n# Access an index within a block\n@show B[Block(1, 1)[1, 1]] == B[1, 1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This page was generated using Literate.jl.","category":"page"}]
}
