var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [BlockSparseArrays]","category":"page"},{"location":"reference/#BlockSparseArrays.SVD","page":"Reference","title":"BlockSparseArrays.SVD","text":"SVD <: Factorization\n\nMatrix factorization type of the singular value decomposition (SVD) of a matrix A. This is the return type of svd(_), the corresponding matrix factorization function.\n\nIf F::SVD is the factorization object, U, S, V and Vt can be obtained via F.U, F.S, F.V and F.Vt, such that A = U * Diagonal(S) * Vt. The singular values in S are sorted in descending order.\n\nIterating the decomposition produces the components U, S, and V.\n\nExamples\n\njulia> A = [1. 0. 0. 0. 2.; 0. 0. 3. 0. 0.; 0. 0. 0. 0. 0.; 0. 2. 0. 0. 0.]\n4×5 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> F = BlockSparseArrays.svd(A)\nBlockSparseArrays.SVD{Float64, Float64, Matrix{Float64}, Vector{Float64}, Matrix{Float64}}\nU factor:\n4×4 Matrix{Float64}:\n 0.0  1.0   0.0  0.0\n 1.0  0.0   0.0  0.0\n 0.0  0.0   0.0  1.0\n 0.0  0.0  -1.0  0.0\nsingular values:\n4-element Vector{Float64}:\n 3.0\n 2.23606797749979\n 2.0\n 0.0\nVt factor:\n4×5 Matrix{Float64}:\n -0.0        0.0  1.0  -0.0  0.0\n  0.447214   0.0  0.0   0.0  0.894427\n  0.0       -1.0  0.0   0.0  0.0\n  0.0        0.0  0.0   1.0  0.0\n\njulia> F.U * Diagonal(F.S) * F.Vt\n4×5 Matrix{Float64}:\n 1.0  0.0  0.0  0.0  2.0\n 0.0  0.0  3.0  0.0  0.0\n 0.0  0.0  0.0  0.0  0.0\n 0.0  2.0  0.0  0.0  0.0\n\njulia> u, s, v = F; # destructuring via iteration\n\njulia> u == F.U && s == F.S && v == F.V\ntrue\n\n\n\n\n\n","category":"type"},{"location":"reference/#BlockSparseArrays.svd!-Tuple{Any}","page":"Reference","title":"BlockSparseArrays.svd!","text":"svd!(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -> SVD\n\nsvd! is the same as svd, but saves space by overwriting the input A, instead of creating a copy. See documentation of svd for details.\n\n\n\n\n\n","category":"method"},{"location":"reference/#BlockSparseArrays.svd-Tuple{Any}","page":"Reference","title":"BlockSparseArrays.svd","text":"svd(A; full::Bool = false, alg::Algorithm = default_svd_alg(A)) -> SVD\n\nCompute the singular value decomposition (SVD) of A and return an SVD object.\n\nU, S, V and Vt can be obtained from the factorization F with F.U, F.S, F.V and F.Vt, such that A = U * Diagonal(S) * Vt. The algorithm produces Vt and hence Vt is more efficient to extract than V. The singular values in S are sorted in descending order.\n\nIterating the decomposition produces the components U, S, and V.\n\nIf full = false (default), a \"thin\" SVD is returned. For an M times N matrix A, in the full factorization U is M times M and V is N times N, while in the thin factorization U is M times K and V is N times K, where K = min(MN) is the number of singular values.\n\nalg specifies which algorithm and LAPACK method to use for SVD:\n\nalg = DivideAndConquer() (default): Calls LAPACK.gesdd!.\nalg = QRIteration(): Calls LAPACK.gesvd! (typically slower but more accurate) .\n\ncompat: Julia 1.3\nThe alg keyword argument requires Julia 1.3 or later.\n\nExamples\n\njulia> A = rand(4,3);\n\njulia> F = BlockSparseArrays.svd(A); # Store the Factorization Object\n\njulia> A ≈ F.U * Diagonal(F.S) * F.Vt\ntrue\n\njulia> U, S, V = F; # destructuring via iteration\n\njulia> A ≈ U * Diagonal(S) * V'\ntrue\n\njulia> Uonly, = BlockSparseArrays.svd(A); # Store U only\n\njulia> Uonly == U\ntrue\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"EditURL = \"../../examples/README.jl\"","category":"page"},{"location":"#BlockSparseArrays.jl","page":"Home","title":"BlockSparseArrays.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable) (Image: Dev) (Image: Build Status) (Image: Coverage) (Image: Code Style: Blue) (Image: Aqua)","category":"page"},{"location":"","page":"Home","title":"Home","text":"A block sparse array type in Julia based on the BlockArrays.jl interface.","category":"page"},{"location":"#Installation-instructions","page":"Home","title":"Installation instructions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package resides in the ITensor/ITensorRegistry local registry. In order to install, simply add that registry through your package manager. This step is only required once.","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg: Pkg\n\njulia> Pkg.Registry.add(url=\"https://github.com/ITensor/ITensorRegistry\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"or:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.Registry.add(url=\"git@github.com:ITensor/ITensorRegistry.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"if you want to use SSH credentials, which can make it so you don't have to enter your Github ursername and password when registering packages.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Then, the package can be added as usual through the package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"BlockSparseArrays\")","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using BlockArrays: BlockArrays, BlockedVector, Block, blockedrange\nusing BlockSparseArrays: BlockSparseArray, blockstoredlength\nusing Test: @test, @test_broken\n\nfunction main()\n  # Block dimensions\n  i1 = [2, 3]\n  i2 = [2, 3]\n\n  i_axes = (blockedrange(i1), blockedrange(i2))\n\n  function block_size(axes, block)\n    return length.(getindex.(axes, Block.(block.n)))\n  end\n\n  # Data\n  nz_blocks = Block.([(1, 1), (2, 2)])\n  nz_block_sizes = [block_size(i_axes, nz_block) for nz_block in nz_blocks]\n  nz_block_lengths = prod.(nz_block_sizes)\n\n  # Blocks with contiguous underlying data\n  d_data = BlockedVector(randn(sum(nz_block_lengths)), nz_block_lengths)\n  d_blocks = [\n    reshape(@view(d_data[Block(i)]), block_size(i_axes, nz_blocks[i])) for\n    i in 1:length(nz_blocks)\n  ]\n  b = BlockSparseArray(nz_blocks, d_blocks, i_axes)\n\n  @test blockstoredlength(b) == 2\n\n  # Blocks with discontiguous underlying data\n  d_blocks = randn.(nz_block_sizes)\n  b = BlockSparseArray(nz_blocks, d_blocks, i_axes)\n\n  @test blockstoredlength(b) == 2\n\n  # Access a block\n  @test b[Block(1, 1)] == d_blocks[1]\n\n  # Access a zero block, returns a zero matrix\n  @test b[Block(1, 2)] == zeros(2, 3)\n\n  # Set a zero block\n  a₁₂ = randn(2, 3)\n  b[Block(1, 2)] = a₁₂\n  @test b[Block(1, 2)] == a₁₂\n\n  # Matrix multiplication\n  @test b * b ≈ Array(b) * Array(b)\n\n  permuted_b = permutedims(b, (2, 1))\n  @test permuted_b isa BlockSparseArray\n  @test permuted_b == permutedims(Array(b), (2, 1))\n\n  @test b + b ≈ Array(b) + Array(b)\n  @test b + b isa BlockSparseArray\n  # TODO: Fix this, broken.\n  @test_broken blockstoredlength(b + b) == 2\n\n  scaled_b = 2b\n  @test scaled_b ≈ 2Array(b)\n  @test scaled_b isa BlockSparseArray\n\n  # TODO: Fix this, broken.\n  @test_broken reshape(b, ([4, 6, 6, 9],)) isa BlockSparseArray{<:Any,1}\n\n  return nothing\nend\n\nmain()","category":"page"},{"location":"#BlockSparseArrays.jl-and-BlockArrays.jl-interface","page":"Home","title":"BlockSparseArrays.jl and BlockArrays.jl interface","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"using BlockArrays: BlockArrays, Block\nusing BlockSparseArrays: BlockSparseArray\n\ni1 = [2, 3]\ni2 = [2, 3]\nB = BlockSparseArray{Float64}(i1, i2)\nB[Block(1, 1)] = randn(2, 2)\nB[Block(2, 2)] = randn(3, 3)\n\n# Minimal interface\n\n# Specifies the block structure\n@show collect.(BlockArrays.blockaxes(axes(B, 1)))\n\n# Index range of a block\n@show axes(B, 1)[Block(1)]\n\n# Last index of each block\n@show BlockArrays.blocklasts(axes(B, 1))\n\n# Find the block containing the index\n@show BlockArrays.findblock(axes(B, 1), 3)\n\n# Retrieve a block\n@show B[Block(1, 1)]\n@show BlockArrays.viewblock(B, Block(1, 1))\n\n# Check block bounds\n@show BlockArrays.blockcheckbounds(B, 2, 2)\n@show BlockArrays.blockcheckbounds(B, Block(2, 2))\n\n# Derived interface\n\n# Specifies the block structure\n@show collect(Iterators.product(BlockArrays.blockaxes(B)...))\n\n# Iterate over block views\n@show sum.(BlockArrays.eachblock(B))\n\n# Reshape into 1-d\n# TODO: Fix this, broken.\n# @show BlockArrays.blockvec(B)[Block(1)]\n\n# Array-of-array view\n@show BlockArrays.blocks(B)[1, 1] == B[Block(1, 1)]\n\n# Access an index within a block\n@show B[Block(1, 1)[1, 1]] == B[1, 1]","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"This page was generated using Literate.jl.","category":"page"}]
}
